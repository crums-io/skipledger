<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (15) on Wed Apr 28 00:41:02 MDT 2021 -->
<title>Ledger (SkipLedger 0.0.1 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2021-04-28">
<meta name="description" content="declaration: package: io.crums.sldg, class: Ledger">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var data = {"i0":6,"i1":9,"i2":10,"i3":9,"i4":10,"i5":10,"i6":6,"i7":10,"i8":9,"i9":6,"i10":9,"i11":6,"i12":9,"i13":10,"i14":9,"i15":9,"i16":10,"i17":10,"i18":9,"i19":9,"i20":9,"i21":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],8:["t4","Concrete Methods"]};
var altColor = "alt-color";
var rowColor = "row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/Ledger.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">io.crums.sldg</a></div>
<h1 title="Class Ledger" class="title">Class Ledger</h1>
</div>
<div class="inheritance" title="Inheritance Tree">java.lang.Object
<div class="inheritance">io.crums.sldg.Ledger</div>
</div>
<section class="description">
<dl class="notes">
<dt>All Implemented Interfaces:</dt>
<dd><code>io.crums.util.hash.Digest</code>, <code>java.io.Closeable</code>, <code>java.lang.AutoCloseable</code></dd>
</dl>
<dl class="notes">
<dt>Direct Known Subclasses:</dt>
<dd><code><a href="CompactLedger.html" title="class in io.crums.sldg">CompactLedger</a></code></dd>
</dl>
<hr>
<pre>public abstract class <span class="type-name-label">Ledger</span>
extends java.lang.Object
implements io.crums.util.hash.Digest, java.io.Closeable</pre>
<div class="block">A <em>skip ledger</em> (new terminology). A skip ledger models a tamper proof
 <a href="https://en.wikipedia.org/wiki/Skip_list">skip list</a>. It's use here
 is as a tamper proof <em>list</em>, not as a search structure. Here are some of its key
 differences:
 <p>
 <ol>
 <li><em>Append only.</em> Items are only ever be appended to the <em>end</em> of the
 list. (In skip list terms, the items are ordered in the ordered in they appear.)</li>
 <li><em>Hash pointers.</em> In lieu of the handles, pointers and such in skip lists,
 the pointers in a skip ledger are hash pointers. (A hash pointer is the hash of another
 node in the skip list.)</li>
 <li><em>Hash of items only.</em> We only ever append the <em>hash</em> of items,
 not the items themselves. (Item storage is an orthogonal issue: they might exist in
 a database table, for example.)</li>
 <li><em>Deterministic structure.</em> The row number (the index of an item in the
 list) uniquely determines the number of skip pointers its corresponding node in the
 skip list has: unlike a skip list, no randomization is involved.</li>
 <li><em>Efficient verification.</em> Whereas a skip list is efficient at search,
 a skip ledger's mojo lies in its efficiency in verification. </li>
 </ol>
 </p><p>
 So a skip ledger is like a tamper proof linked list, but on link steroids. The main
 advantage it offers over a (singlely) linked tamper proof list is that you don't need
 to show the whole list (or any substantial part of it) in order to prove an item's position in
 in the list.
 </p><p>
 Which list? In the same way that the root hash of a Merkle tree uniquely identifies
 the tree, the hash of the last row (node) in a skip ledger uniquely identifies the ledger
 (the append-only list). To prove that an item is in the ledger (its hash actually--equivalently)
 one needs to enumerate a list of linked rows (nodes) from the last row in the ledger (whose hash
 defines the ledger's state) to the row number (index) at which the item is located. With
 a skip ledger, the number of rows in such hash proofs is on the order of the logarithm
 of the number of rows in the ledger.
 </p>
 <h2>Historical Annotations</h2>
 <p>
 The skip ledger data structure itself encodes no information about time. And to the
 degree practical, this class eschew's knowledge of the strategy we use to embed historical
 information. Still, it's useful to document here how it's done.
 </p><p>
 Historical information is layered above, and embedded into, a ledger in 2 ways:
 </p><p>
 <ol>
 <li><em>Crumtrails.</em> A crumtrail (crums.io witness record) of a row's hash is annotated
 to the row. This is establishes the minumum age of the row (and every row that precedes it).
 </li>
 <li><em>Beacon rows.</em> The root hash of the periodic (threaded) Merkle trees that crums.io
 publishes and keeps track of cannot be computed in advance. These serve as time beacons and
 are embedded as special rows in the ledger. The presence of a beacon row ahead of later
 rows establishes the maximum age of subsequent rows.</li>
 </ol>
 </p><p>
 These 2 mechanisms sandwich time for any interleaving row. They establish a tamper proof inequality (minimum and maximum age)
 for any row interleaving (and including) the witnessed row and the beacon row. Again, this
 historical data is only hinted at in this abstraction, and the implementation does not
 actually require such data.
 </p>
 <h2>Abbreviated State</h2>
 <p>
 Since our ledger is composed entirely of opaque hashes, we <em>could</em> share the entire ledger
 with 3rd parties for verification purposes (as when verifying the contents of a single row).
 This is similar to how one verifies items on standard blockchains: you generally need access to
 the whole chain. Verifying things is still faster using our skip ledger than walking a
 linked list linearly. But we can do better.
 </p><p>
 As discussed above, the hash of a ledger's last row uniquely identifies the ledger itself.
 A hash is a kind of contraction of state (perhaps why it's also called a digest). But <em>the
 skip ledger data structure also offers an intermediate contraction of state, namely the
 shortest path of linked rows from the last to first</em>. Again, the size of this representation is logarithmic
 in the number of rows in the ledger, so it's compact no matter the ledger size.
 </p><p>
 The advantage with advertising the state of a ledger this way is that if it intersects with
 a previously emitted path from the ledger (when the ledger had fewer rows), then the previous
 path (e.g. proof that an entry belonged in the ledger at the advertised row number) can be
 patched with the new state information.
 </p><p>
 The issue where this state information comes from, how it is validated, etc., is a can
 deliberately kicked down the road. It could be simply advertised over HTTPS with the existing
 certificate authority mechanisms. Or the owner of the ledger might insert their public key
 as the first row, and then periodically add a public entry (the contents of a row they make
 public) that is a signature of the previous row's hash. The choices are too many to consider at
 this juncture and probably best left to evolve.
 </p>
 <h2>Row Numbering</h2>
 <p>
 A row's number in the ledger uniquely determines how many pointers it has (see <a href="#skipCount(long)">skipCount(long)</a>
 (and which row numbers they point to). An important point to note is that the indexing is
 1-based, not zero based. The 1st row added to a ledger is numbered 1. This is mostly for convenience:
 calculating the number of skip pointers is easier in the 1-based system.
 </p><p>
 Note conceptually, the zero'th row is a special sentinel in every ledger. Its hash evaluates to a string of
 zero-bytes (as wide as the hash algo requires), the contents of which.. well who knows. (And
 for our purposes, it wouldn't matter if it were discovered by chance (practically impossible), by say some Bitcoin miner).
 </p>
 <h3>Sans-Beacon Numbering</h3>
 <p>
 The presence of beacon rows in a ledger is arguably a wart in the data model. After all, the
 decision whether or not to insert a beacon row (a timestamping decision) ought to be orthogonal
 to the order of operations captured in the ledger. Fortunately, the layer that handles historical
 information (beacons and crumtrails) also exposes a sans-beacon numbering scheme. This might allow one to infer,
 for example, a database table row's position in the ledger simply by its position in the table
 (i.e. without beacon bookkeeping). See (<a href="db/Db.html#rowNumSansBeacons(long)">Db.rowNumSansBeacons(long)</a>.
 </p></div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor.summary">
<h2>Constructor Summary</h2>
<div class="member-summary">
<table class="summary-table">
<caption><span>Constructors</span></caption>
<thead>
<tr>
<th class="col-first" scope="col">Constructor</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color">
<th class="col-constructor-name" scope="row"><code><span class="member-name-link"><a href="#%3Cinit%3E()">Ledger</a></span>()</code></th>
<td class="col-last">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method.summary">
<h2>Method Summary</h2>
<div class="member-summary" id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="active-table-tab">All Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t1" class="table-tab" onclick="show(1);">Static Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="table-tab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t3" class="table-tab" onclick="show(4);">Abstract Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t4" class="table-tab" onclick="show(8);">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<table class="summary-table" aria-labelledby="t0">
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Method</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color" id="i0">
<td class="col-first"><code>abstract long</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#appendRows(java.nio.ByteBuffer)">appendRows</a></span>&#8203;(java.nio.ByteBuffer&nbsp;entryHashes)</code></th>
<td class="col-last">
<div class="block">Appends one or more hash entries to the end of the ledger.</div>
</td>
</tr>
<tr class="row-color" id="i1">
<td class="col-first"><code>static void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#checkRealRowNumber(long)">checkRealRowNumber</a></span>&#8203;(long&nbsp;rowNumber)</code></th>
<td class="col-last">
<div class="block">Throws an <tt>IllegalArgumentException</tt> if the given row number is not &ge; 1.</div>
</td>
</tr>
<tr class="alt-color" id="i2">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#close()">close</a></span>()</code></th>
<td class="col-last">&nbsp;</td>
</tr>
<tr class="row-color" id="i3">
<td class="col-first"><code>static java.util.SortedSet&lt;java.lang.Long&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#coverage(java.util.Collection)">coverage</a></span>&#8203;(java.util.Collection&lt;java.lang.Long&gt;&nbsp;rowNumbers)</code></th>
<td class="col-last">
<div class="block">Returns the rows <em>covered</em> by the given row numbers.</div>
</td>
</tr>
<tr class="alt-color" id="i4">
<td class="col-first"><code><a href="Path.html" title="class in io.crums.sldg">Path</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#getPath(java.lang.Long...)">getPath</a></span>&#8203;(java.lang.Long...&nbsp;targets)</code></th>
<td class="col-last">
<div class="block">Returns a path linking the given the target row numbers.</div>
</td>
</tr>
<tr class="row-color" id="i5">
<td class="col-first"><code><a href="Path.html" title="class in io.crums.sldg">Path</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#getPath(java.util.List)">getPath</a></span>&#8203;(java.util.List&lt;java.lang.Long&gt;&nbsp;targets)</code></th>
<td class="col-last">
<div class="block">Returns a path linking the given the target row numbers.</div>
</td>
</tr>
<tr class="alt-color" id="i6">
<td class="col-first"><code>abstract <a href="Row.html" title="class in io.crums.sldg">Row</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#getRow(long)">getRow</a></span>&#8203;(long&nbsp;rowNumber)</code></th>
<td class="col-last">
<div class="block">Returns the row with the given number.</div>
</td>
</tr>
<tr class="row-color" id="i7">
<td class="col-first"><code>boolean</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#isEmpty()">isEmpty</a></span>()</code></th>
<td class="col-last">&nbsp;</td>
</tr>
<tr class="alt-color" id="i8">
<td class="col-first"><code>static java.util.SortedSet&lt;java.lang.Long&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#refOnlyCoverage(java.util.Collection)">refOnlyCoverage</a></span>&#8203;(java.util.Collection&lt;java.lang.Long&gt;&nbsp;rowNumbers)</code></th>
<td class="col-last">&nbsp;</td>
</tr>
<tr class="row-color" id="i9">
<td class="col-first"><code>abstract java.nio.ByteBuffer</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#rowHash(long)">rowHash</a></span>&#8203;(long&nbsp;rowNumber)</code></th>
<td class="col-last">
<div class="block">Returns the hash of the row at the given number.</div>
</td>
</tr>
<tr class="alt-color" id="i10">
<td class="col-first"><code>static boolean</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#rowsLinked(long,long)">rowsLinked</a></span>&#8203;(long&nbsp;rowNumA,
long&nbsp;rowNumB)</code></th>
<td class="col-last">
<div class="block">Determines if any of the 2 rows (from the same ledger) with given row numbers
 reference (and therefore link to) the other by hash.</div>
</td>
</tr>
<tr class="row-color" id="i11">
<td class="col-first"><code>abstract long</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#size()">size</a></span>()</code></th>
<td class="col-last">
<div class="block">Returns the number of rows in this ledger.</div>
</td>
</tr>
<tr class="alt-color" id="i12">
<td class="col-first"><code>static int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#skipCount(long)">skipCount</a></span>&#8203;(long&nbsp;rowNumber)</code></th>
<td class="col-last">
<div class="block">Returns the number of skip pointers at the given row number.</div>
</td>
</tr>
<tr class="row-color" id="i13">
<td class="col-first"><code><a href="SkipPath.html" title="class in io.crums.sldg">SkipPath</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#skipPath(long,long)">skipPath</a></span>&#8203;(long&nbsp;lo,
long&nbsp;hi)</code></th>
<td class="col-last">
<div class="block">Returns the skip-path (the shortest string of rows) connecting the row with the
 given <tt>lo</tt> number from the row with the given <tt>hi</tt> number.</div>
</td>
</tr>
<tr class="alt-color" id="i14">
<td class="col-first"><code>static java.util.SortedSet&lt;java.lang.Long&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#skipPathCoverage(long,long)">skipPathCoverage</a></span>&#8203;(long&nbsp;lo,
long&nbsp;hi)</code></th>
<td class="col-last">
<div class="block">Returns the rows <em>covered</em> by the specified skip path.</div>
</td>
</tr>
<tr class="row-color" id="i15">
<td class="col-first"><code>static java.util.List&lt;java.lang.Long&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#skipPathNumbers(long,long)">skipPathNumbers</a></span>&#8203;(long&nbsp;lo,
long&nbsp;hi)</code></th>
<td class="col-last">
<div class="block">Returns the structural path from a lower
 (older) row number to a higher (more recent) row number in a ledger.</div>
</td>
</tr>
<tr class="alt-color" id="i16">
<td class="col-first"><code>java.nio.ByteBuffer</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#stateHash()">stateHash</a></span>()</code></th>
<td class="col-last">
<div class="block">Returns a hash representing the current state of the ledger.</div>
</td>
</tr>
<tr class="row-color" id="i17">
<td class="col-first"><code><a href="SkipPath.html" title="class in io.crums.sldg">SkipPath</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#statePath()">statePath</a></span>()</code></th>
<td class="col-last">
<div class="block">Returns the skip-path from row 1 to the row numbered <a href="#size()">size</a>,
 or <tt>null</tt> if this ledger is empty.</div>
</td>
</tr>
<tr class="alt-color" id="i18">
<td class="col-first"><code>static java.util.List&lt;java.lang.Long&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#stitch(java.util.List)">stitch</a></span>&#8203;(java.util.List&lt;java.lang.Long&gt;&nbsp;rowNumbers)</code></th>
<td class="col-last">
<div class="block">Stitches and returns a copy of the given (sorted) list of row numbers that is
 composed of the given list interleaved with linking row numbers as necessary.</div>
</td>
</tr>
<tr class="row-color" id="i19">
<td class="col-first"><code>static java.util.Optional&lt;java.util.List&lt;java.lang.Long&gt;&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#stitchPath(java.util.SortedSet,long,long)">stitchPath</a></span>&#8203;(java.util.SortedSet&lt;java.lang.Long&gt;&nbsp;knownRows,
long&nbsp;lo,
long&nbsp;hi)</code></th>
<td class="col-last">
<div class="block">Finds and returns a structural path from <code>lo</code> to <code>hi</code> (the skip pointers
 actually go hi to lo, but we present paths in the order they are created) stitched
 together using only the given <code>knownRows</code>.</div>
</td>
</tr>
<tr class="alt-color" id="i20">
<td class="col-first"><code>static java.util.Optional&lt;java.util.List&lt;java.lang.Long&gt;&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#stitchPath(java.util.SortedSet,java.lang.Long...)">stitchPath</a></span>&#8203;(java.util.SortedSet&lt;java.lang.Long&gt;&nbsp;knownRows,
java.lang.Long...&nbsp;target)</code></th>
<td class="col-last">
<div class="block">Finds and returns a structural path connecting the given <code>target</code> rows stitched
 together using only the given <code>knownRows</code>.</div>
</td>
</tr>
<tr class="row-color" id="i21">
<td class="col-first"><code>static java.util.Optional&lt;java.util.List&lt;java.lang.Long&gt;&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#stitchPath(java.util.SortedSet,java.util.Collection)">stitchPath</a></span>&#8203;(java.util.SortedSet&lt;java.lang.Long&gt;&nbsp;knownRows,
java.util.Collection&lt;java.lang.Long&gt;&nbsp;targets)</code></th>
<td class="col-last">
<div class="block">Finds and returns a structural path connecting the given target rows stitched
 together using only the given <code>knownRows</code>.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="inherited-list">
<h3 id="methods.inherited.from.class.java.lang.Object">Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></div>
<div class="inherited-list">
<h3 id="methods.inherited.from.class.io.crums.util.hash.Digest">Methods inherited from interface&nbsp;io.crums.util.hash.Digest</h3>
<code>hashAlgo, hashWidth, newDigest, sentinelHash</code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor.detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;()">
<h3>Ledger</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="member-name">Ledger</span>()</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method.detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="skipCount(long)">
<h3>skipCount</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">skipCount</span>&#8203;(<span class="parameters">long&nbsp;rowNumber)</span></div>
<div class="block"><p>Returns the number of skip pointers at the given row number. The
 returned number is one plus the <em>exponent</em> in the highest power of 2 that is
 a factor of the row number. For odd row numbers, this is always 1 (since the highest
 factor here is 2<sup><small>0</small></sup>).</p>
 
 <h3>Strict Law of Averages</h3>
 
 <p>The <em>average</em> number of skip pointers is <em>always</em> less than 2.
 Equivalently, the total number of skip pointers up to (and including) a given row
 number, is always less than twice the row number.
 </p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>rowNumber</code> - &ge; 1</dd>
<dt>Returns:</dt>
<dd>&ge; 1 (with average value of 2)</dd>
<dt>See Also:</dt>
<dd><code>#maxRows(long)</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="rowsLinked(long,long)">
<h3>rowsLinked</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="member-name">rowsLinked</span>&#8203;(<span class="parameters">long&nbsp;rowNumA,
long&nbsp;rowNumB)</span></div>
<div class="block">Determines if any of the 2 rows (from the same ledger) with given row numbers
 reference (and therefore link to) the other by hash. Since every row knows its own hash,
 by this definition, every row is linked also linked to itself.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>rowNumA</code> - &ge; 0 (zero OK!)</dd>
<dd><code>rowNumB</code> - &ge; 0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="checkRealRowNumber(long)">
<h3>checkRealRowNumber</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">checkRealRowNumber</span>&#8203;(<span class="parameters">long&nbsp;rowNumber)</span>
                               throws <span class="exceptions">java.lang.IllegalArgumentException</span></div>
<div class="block">Throws an <tt>IllegalArgumentException</tt> if the given row number is not &ge; 1.
 If the row number is zero, the thrown exception details why row <tt>0</tt> is a bad
 argument.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>rowNumber</code> - &ge; 1</dd>
<dt>Throws:</dt>
<dd><code>java.lang.IllegalArgumentException</code> - if <tt>rowNumber &le; 0</tt></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="skipPathCoverage(long,long)">
<h3>skipPathCoverage</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">java.util.SortedSet&lt;java.lang.Long&gt;</span>&nbsp;<span class="member-name">skipPathCoverage</span>&#8203;(<span class="parameters">long&nbsp;lo,
long&nbsp;hi)</span></div>
<div class="block">Returns the rows <em>covered</em> by the specified skip path. The rows covered
 include both the linking rows and all the rows referenced in the linking rows.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>lo</code> - row number &ge; 1</dd>
<dd><code>hi</code> - row number &ge; <code>lo</code></dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="coverage(java.util.Collection)">
<h3>coverage</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">java.util.SortedSet&lt;java.lang.Long&gt;</span>&nbsp;<span class="member-name">coverage</span>&#8203;(<span class="parameters">java.util.Collection&lt;java.lang.Long&gt;&nbsp;rowNumbers)</span></div>
<div class="block">Returns the rows <em>covered</em> by the given row numbers. The returned
 ordered set contains both the given row numbers and the row numbers referenced
 in the rows at those row numbers. Altho its size is sensitive to its inputs,
 the returned list never blows up: it's size may grow at most by a factor that
 is no greater than the base 2 log of the highest row number in its input.
 <p>
 <em>Note the returned set may (and likely does) contain the sentinel row number 0 (zero).
 </em> The reason why is that the returned set, is the set of row numbers whose
 hashes are needed to compute the hashes of the given row numbers. And while the contents
 of the sentinel row are undefined, it's hash <em>is</em>.
 </p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>rowNumbers</code> - non-empty bag of positive (&ge; 1) numbers,
        in whatever order, dups OK</dd>
<dt>Returns:</dt>
<dd>non-empty set of row</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="refOnlyCoverage(java.util.Collection)">
<h3>refOnlyCoverage</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">java.util.SortedSet&lt;java.lang.Long&gt;</span>&nbsp;<span class="member-name">refOnlyCoverage</span>&#8203;(<span class="parameters">java.util.Collection&lt;java.lang.Long&gt;&nbsp;rowNumbers)</span></div>
</section>
</li>
<li>
<section class="detail" id="stitch(java.util.List)">
<h3>stitch</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">java.util.List&lt;java.lang.Long&gt;</span>&nbsp;<span class="member-name">stitch</span>&#8203;(<span class="parameters">java.util.List&lt;java.lang.Long&gt;&nbsp;rowNumbers)</span></div>
<div class="block">Stitches and returns a copy of the given (sorted) list of row numbers that is
 composed of the given list interleaved with linking row numbers as necessary.
 If <code>rowNumbers</code> is already stitched, a new copy is still returned.
 <p>
 This method supports an abbreviated path specification.
 </p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>rowNumbers</code> - not empty, monotonically increasing, positive row numbers</dd>
<dt>Returns:</dt>
<dd>a new read-only list of unique, sorted numbers</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="stitchPath(java.util.SortedSet,java.lang.Long...)">
<h3>stitchPath</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">java.util.Optional&lt;java.util.List&lt;java.lang.Long&gt;&gt;</span>&nbsp;<span class="member-name">stitchPath</span>&#8203;(<span class="parameters">java.util.SortedSet&lt;java.lang.Long&gt;&nbsp;knownRows,
java.lang.Long...&nbsp;target)</span></div>
<div class="block">Finds and returns a structural path connecting the given <code>target</code> rows stitched
 together using only the given <code>knownRows</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>knownRows</code> - known (available) row numbers from which the path may be constructed</dd>
<dd><code>targets</code> - target row numbers (must all be contained in <code>knownRows</code>)
                in no particular order, but with no duplicates</dd>
<dt>Returns:</dt>
<dd>the path, if found; empty, o.w.</dd>
<dt>See Also:</dt>
<dd><a href="#stitchPath(java.util.SortedSet,java.util.Collection)"><code>stitchPath(SortedSet, Collection)</code></a>, 
<a href="#stitchPath(java.util.SortedSet,long,long)"><code>stitchPath(SortedSet, long, long)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="stitchPath(java.util.SortedSet,java.util.Collection)">
<h3>stitchPath</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">java.util.Optional&lt;java.util.List&lt;java.lang.Long&gt;&gt;</span>&nbsp;<span class="member-name">stitchPath</span>&#8203;(<span class="parameters">java.util.SortedSet&lt;java.lang.Long&gt;&nbsp;knownRows,
java.util.Collection&lt;java.lang.Long&gt;&nbsp;targets)</span></div>
<div class="block">Finds and returns a structural path connecting the given target rows stitched
 together using only the given <code>knownRows</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>knownRows</code> - known (available) row numbers from which the path may be constructed</dd>
<dd><code>targets</code> - target row numbers (must all be contained in <code>knownRows</code>)
                in no particular order, but with no duplicates</dd>
<dt>Returns:</dt>
<dd>the path, if found; empty, o.w.</dd>
<dt>See Also:</dt>
<dd><a href="#stitchPath(java.util.SortedSet,java.lang.Long...)"><code>stitchPath(SortedSet, Long...)</code></a>, 
<a href="#stitchPath(java.util.SortedSet,long,long)"><code>stitchPath(SortedSet, long, long)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="stitchPath(java.util.SortedSet,long,long)">
<h3>stitchPath</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">java.util.Optional&lt;java.util.List&lt;java.lang.Long&gt;&gt;</span>&nbsp;<span class="member-name">stitchPath</span>&#8203;(<span class="parameters">java.util.SortedSet&lt;java.lang.Long&gt;&nbsp;knownRows,
long&nbsp;lo,
long&nbsp;hi)</span></div>
<div class="block">Finds and returns a structural path from <code>lo</code> to <code>hi</code> (the skip pointers
 actually go hi to lo, but we present paths in the order they are created) stitched
 together using only the given <code>knownRows</code>.
 <p>
 Note the skip pointers actually point in the opposite direction, from hi to lo,
 but we present paths in the order they are created (equivalently, in the order
 rows are numbered.)
 </p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>knownRows</code> - known (available) row numbers from which the path may be constructed</dd>
<dd><code>lo</code> - &ge; 1, and contained in (member of) <code>knownRows</code></dd>
<dd><code>hi</code> - &gt; lo, and contained in <code>knownRows</code></dd>
<dt>Returns:</dt>
<dd>the path, if found; empty, o.w.</dd>
<dt>See Also:</dt>
<dd><a href="#stitchPath(java.util.SortedSet,java.util.Collection)"><code>stitchPath(SortedSet, Collection)</code></a>, 
<a href="#stitchPath(java.util.SortedSet,java.lang.Long...)"><code>stitchPath(SortedSet, Long...)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="skipPathNumbers(long,long)">
<h3>skipPathNumbers</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">java.util.List&lt;java.lang.Long&gt;</span>&nbsp;<span class="member-name">skipPathNumbers</span>&#8203;(<span class="parameters">long&nbsp;lo,
long&nbsp;hi)</span></div>
<div class="block">Returns the structural path from a lower
 (older) row number to a higher (more recent) row number in a ledger.
 This is just the shortest structural path following the hash pointers in each
 row from the <tt>hi</tt> row number to the <tt>lo</tt> one. The returned list
 however is returned in reverse order, in keeping with the temporal order of
 ledgers.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>lo</code> - row number &gt; 0</dd>
<dd><code>hi</code> - row number &ge; <code>lo</code></dd>
<dt>Returns:</dt>
<dd>a monotonically ascending list of numbers from <tt>lo</tt> to </tt>hi</tt>,
         inclusive</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="appendRows(java.nio.ByteBuffer)">
<h3>appendRows</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="member-name">appendRows</span>&#8203;(<span class="parameters">java.nio.ByteBuffer&nbsp;entryHashes)</span></div>
<div class="block">Appends one or more hash entries to the end of the ledger.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>entryHashes</code> - the input hash of the next <a href="Row.html" title="class in io.crums.sldg">row</a></dd>
<dt>Returns:</dt>
<dd>the new size of the ledger, or equivalently, the row number of the last
 entry just added</dd>
<dt>See Also:</dt>
<dd><code>Digest.hashWidth()</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="size()">
<h3>size</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="member-name">size</span>()</div>
<div class="block">Returns the number of rows in this ledger. Recall the row numbers are one-based,
 so if the ledger is not empty, then the return value also represents that last existing
 row number.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>&ge; 0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="isEmpty()">
<h3>isEmpty</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="member-name">isEmpty</span>()</div>
</section>
</li>
<li>
<section class="detail" id="getRow(long)">
<h3>getRow</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Row.html" title="class in io.crums.sldg">Row</a></span>&nbsp;<span class="member-name">getRow</span>&#8203;(<span class="parameters">long&nbsp;rowNumber)</span></div>
<div class="block">Returns the row with the given number.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>rowNumber</code> - positive (&gt; 0), since the sentinel row is <em>abstract</em> (a row
                  whose hash is identically zero)</dd>
<dt>Returns:</dt>
<dd>non-null</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="rowHash(long)">
<h3>rowHash</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type">java.nio.ByteBuffer</span>&nbsp;<span class="member-name">rowHash</span>&#8203;(<span class="parameters">long&nbsp;rowNumber)</span></div>
<div class="block">Returns the hash of the row at the given number.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>rowNumber</code> - non-negative (&ge; 0), but note that row zero is a sentinel;
        the effective row numbers are 1-based</dd>
<dt>Returns:</dt>
<dd>a possibly read-only buffer</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="stateHash()">
<h3>stateHash</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">java.nio.ByteBuffer</span>&nbsp;<span class="member-name">stateHash</span>()</div>
<div class="block">Returns a hash representing the current state of the ledger.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the hash of the last row, if not empty; the sentinel hash (all zeroes), if empty.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="statePath()">
<h3>statePath</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type"><a href="SkipPath.html" title="class in io.crums.sldg">SkipPath</a></span>&nbsp;<span class="member-name">statePath</span>()</div>
<div class="block">Returns the skip-path from row 1 to the row numbered <a href="#size()">size</a>,
 or <tt>null</tt> if this ledger is empty.</div>
</section>
</li>
<li>
<section class="detail" id="skipPath(long,long)">
<h3>skipPath</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type"><a href="SkipPath.html" title="class in io.crums.sldg">SkipPath</a></span>&nbsp;<span class="member-name">skipPath</span>&#8203;(<span class="parameters">long&nbsp;lo,
long&nbsp;hi)</span></div>
<div class="block">Returns the skip-path (the shortest string of rows) connecting the row with the
 given <tt>lo</tt> number from the row with the given <tt>hi</tt> number.</div>
</section>
</li>
<li>
<section class="detail" id="getPath(java.lang.Long...)">
<h3>getPath</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type"><a href="Path.html" title="class in io.crums.sldg">Path</a></span>&nbsp;<span class="member-name">getPath</span>&#8203;(<span class="parameters">java.lang.Long...&nbsp;targets)</span></div>
<div class="block">Returns a path linking the given the target row numbers.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>targets</code> - strictly ascending list of row numbers (&le; <a href="#size()">size()</a>)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getPath(java.util.List)">
<h3>getPath</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type"><a href="Path.html" title="class in io.crums.sldg">Path</a></span>&nbsp;<span class="member-name">getPath</span>&#8203;(<span class="parameters">java.util.List&lt;java.lang.Long&gt;&nbsp;targets)</span></div>
<div class="block">Returns a path linking the given the target row numbers.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>targets</code> - non-empty, strictly ascending list of row numbers (&le; <a href="#size()">size()</a>)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="close()">
<h3>close</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">close</span>()</div>
<dl class="notes">
<dt>Specified by:</dt>
<dd><code>close</code>&nbsp;in interface&nbsp;<code>java.lang.AutoCloseable</code></dd>
<dt>Specified by:</dt>
<dd><code>close</code>&nbsp;in interface&nbsp;<code>java.io.Closeable</code></dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottom-nav" id="navbar.bottom">
<div class="skip-nav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.bottom.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/Ledger.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<span class="skip-nav" id="skip.navbar.bottom">
<!--   -->
</span></nav>
<p class="legal-copy"><small>Copyright &#169; 2021. All rights reserved.</small></p>
</footer>
</div>
</div>
</body>
</html>
